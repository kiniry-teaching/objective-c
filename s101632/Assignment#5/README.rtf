{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 I chose to implement the priority queue to get at little taste of data structures, before I will have a course on data structures  and algorithms next semester.\
I chose to store the queue in a mutable array, I don't know if it is the most efficient because every time you add a new object to the queue you will have to sort the entire array but when you have to retrieve the peak and the poll it is in constant time which is really fast.\
I think i might be more effective to store the queue in a linked list or a binary tree.\
By implementing the PriorityQueue I finally got a understanding of where and how to use blocks.\
I have been using assertion to validate the pre- and postconditions in the code.\
\
I have also tried to translate the java.util.timer API, which has not been completely successful. There is som bug in the code that I can't find. I hope you can help me with finding the bug.\
My plan was to have a a secondary thread that would keep checking the first timer task in the queue if it is time to fire that task. I have used the priority queue that I wrote in the first part of assignment 5, and sorts the tasks by the their action date.}