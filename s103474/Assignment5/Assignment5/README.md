# Assignment 5: Reflecting on APIs

## Introduction

For this final assignment in the Objective-C course, I have decided to make a port of _SmartyPants_, a set of methods that automate the application of proper typography (such as “smart quotes”, ellipses, etc.) in texts for output in a HTML context by transforming an input string. It's originally a Perl script written by John Gruber (of Daring Fireball) and Brad Choate, and this original can be found here:

http://daringfireball.net/projects/smartypants/

I use it often in my own web projects because I am passionate about proper typography, but I am not very proficient in Perl. Thus, in my own projects and in this port, I have used the PHP version (itself a port) of the SmartyPants script. This version is made by Michel Fortin and is, contrary to the Perl version, object oriented (with one central `SmartyPants_Parser` class), which made it easier to port to Objective-C. The PHP version can be found here:

http://michelf.ca/projects/php-smartypants/

Henceforth, the above will be referred to as the "original API" in the context of my port. The source files for the original API can be found in the "Original Files" subfolder. These source files have a lot of comments regarding how the methods work, and where my port doesn't change the mechanisms, I didn't write any comments in my port. Thus, read the comments in the original API source if you wish to understand more about the internal mechanisms and structure.

## Design and architecture of original API

The original API is a set of methods that assist typography on the web by transforming an input string such that simple "straight quotes" are replaced by (the unicode HTML entities for) “smart quotes” and other similarly sofisticated typographical characters which are not easy to find on one's own keyboard and would be hard to type directly.

The external set of methods used in this fashion consists of various methods (and amongst them, quick shorthands) that all call a `SmartyPants_Parser` class, of which an object is created with arguments detailing transformation settings desired (enabling quotes, ellipses, etc). Then, the `transform` method is called, which transforms the string, and internally calls many of the object's other methods in order to perform the task.

Even though this is written in a language (PHP) that, although it has object-oriented features, is decidely not (strongly) object-oriented, the original API still *is* object-oriented, although only moderately and modestly. Many of the features that are required in a strong object-oriented language and that PHP does allow, but not require, are not used here. For example, not a single one of the methods declared and defined in the `SmartyPants_Parser` class have an access modifier (`public`, `private`, `protected`, etc.), even though only very few of the methods actually need to be public. Not only this, not even the instance variables have any access modifiers — even though they are all internal to the object's mechanism, *none* of them are set to be private. 

## Port process and decisions

Even though the original script had the shortcomings mentioned above, as it turned out, many things were actually quite easy to translate to Objective-C. For example, the method structure was largely kept intact, although I explicitly set many methods to private by not declaring them in the `@interface` section, and all the `@property`-ies were similarly not declared in the `.h` file. Also, many methods were named slightly differently in the Objective-C port to match the default naming scheme of the language (with *camelCase* and argument names).

One of the major differences between the languages, and thus, between the two implementations of the script, is that the PHP scripting language is much more forgiving when it comes to variable definition and use, due to its dynamic typing and that a variable is not explicitly declared, unlike in Objective-C. Because of this, and Objective-C's at times very verbose method names, the Objective-C implementation is probably larger, in terms of bytes.

The original API is very dependent on *regular expressions*, which are implemented using the PCRE (*Perl-Compatible Regular Expressions*) library in PHP, and which I implemented using the `NSRegularExpression` class in Objective-C. This is *not* implemented using PCRE, and thus, many of the regular expressions used in the definition of the original API's methods had to be rewritten either slightly or substantially for the port. This made me fear that it would not be possible to detect certain character patterns due to limitations, but in the end, it was possible to tame the `NSRegularExpression` class of methods, and only one single (non-substiantial) part of *one* of all of the regular expressions had to be scrapped due to lack of functionality support. So even though the syntax had to be tweaked a bit, in the end, the same things were possible.

However, as it turns out, the internal API for performing matches, replaces and splits in strings using regular expressions is implented very differently in the two languages. This fact provided quite a bit of porting challenges. While the PHP PCRE API is not object-oriented in the slightest, which means it's simply a bunch of functions you're calling, the Objective-C regular expression API on the other hand is fully object-oriented. This means that you create an `NSRegularExpression` object with the expression, and then send messages to that object to get the results. This results in a more structured approach, but also in much more verbose code, which meant I had to create internal shorthand methods just to keep myself sane sometimes. On the other hand, it has more fine-grained control, as seen in the method names `matchesInString`, `numberOfMatchesInString` and `firstMatchInString`, all of which I ended up using.

In terms of more general Objective-C coding style, I used the new aspects of "modern Objective-C" heavily in this port. Even though I only learned this language very recently, I can tell that the new ways to type literals are much better than the previous methods I see in old teaching materials, and I enjoy being able to use these.

The original API had several non-class functions which were added as shorthands into the parser object. Because of this, in addition to the various initialisers (`init...` methods) created, which all allow for different methods of specifying configuration arguments to the `SmartyPantsParser` object, some static class methods were added to make these quick entry points into the parser. These could normally be called "factory methods", but they don't actually return the parser object itself, so this is not a justified label in this case. Instead, they directly return the transformed string, with the given input string and configuration arguments directly specified. This ranges from simple, flexible methods such as `+(NSString *)transformString:(NSString *)input usingAttributes:(int)attr`, to constrained shorthands such as `+(NSString *)smartQuotes:(NSString *)input`.

But perhaps most interesting in this port is the many categories I ended up appending to existing Objective-C objects in order to add functionality that either existed in native PHP APIs or convenience methods that were better placed here. This, I think, is one of the most valuable lessons learned during this port, concerning Objective-C philosophy and coding style. From simple methods to getting the last character of a string (method `lastCharacter` added to `NSString`), to more advanced missing required functionality such as splitting a string by a delimiter specified by a regular expression (method `splitByMatchesInString:options:range:` added to `NSRegularExpression`), I created many custom methods to handle these tasks. But I originally placed them internally inside the `SmartyPantsParser` object until I realised that it is **a crucial part of Objective-C's strong object-oriented philosophy that these are placed in categories that are appended to the objects in which they belong/modify.** Many Objective-C APIs already do this, even some of the native ones. `UIKit` is known to add to `Foundation`, and so on. It happens all the time. In this assignment, where it was important to embrace every normal way of doing things in the language, I feel I truly did so in this port — and the fact that I added required methods for my object into far away categories, something I've never done before in my life, makes it evident how much I've delved into something truly different and how much I've learned about Objective-C. It's been a very interesting process.

Build and run the `main.m` file to see several examples of the `SmartyPantsParser` in action.

—Andy
